"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware2;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n\nvar _extends = __webpack_require__(/*! @swc/helpers/_/_extends */ \"./node_modules/@swc/helpers/esm/_extends.js\");\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware2(options) {\n  return _matchesMiddleware.apply(this, arguments);\n}\n\nfunction _matchesMiddleware() {\n  _matchesMiddleware = _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n    var matchers, _ref, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n          case 2:\n            matchers = _context.sent;\n\n            if (matchers) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 5:\n            _ref = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n            cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n            asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n            // where we can access more info such as headers, HttpOnly cookie, etc.\n\n            return _context.abrupt(\"return\", matchers.some(function (m) {\n              return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n            }));\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _matchesMiddleware.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref2 = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref3 = _slicedToArray(_ref2, 2),\n      resolvedHref = _ref3[0],\n      resolvedAs = _ref3[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get('x-nextjs-rewrite');\n  var rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n  var matchedPath = response.headers.get('x-matched-path');\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith('/') || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            pages = _ref5[0],\n            rewrites = _ref5[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: 'rewrite',\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_extends._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    }), {\n      defaultLocale: options.router.defaultLocale,\n      buildId: ''\n    }));\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n    });\n  }\n\n  var redirectTarget = response.headers.get('x-nextjs-redirect');\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_extends._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      }), {\n        defaultLocale: options.router.defaultLocale,\n        buildId: ''\n      }));\n\n      return Promise.resolve({\n        type: 'redirect-internal',\n        newAs: \"\".concat(_pathname).concat(_src.query).concat(_src.hash),\n        newUrl: \"\".concat(_pathname).concat(_src.query).concat(_src.hash)\n      });\n    }\n\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: 'next'\n  });\n}\n\nfunction withMiddlewareEffects(options) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n    var matches, data, effect;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _matchesMiddleware2(options);\n\n          case 2:\n            matches = _context2.sent;\n\n            if (!(!matches || !options.fetchData)) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 5:\n            _context2.prev = 5;\n            _context2.next = 8;\n            return options.fetchData();\n\n          case 8:\n            data = _context2.sent;\n            _context2.next = 11;\n            return getMiddlewareData(data.dataHref, data.response, options);\n\n          case 11:\n            effect = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              dataHref: data.dataHref,\n              json: data.json,\n              response: data.response,\n              text: data.text,\n              cacheKey: data.cacheKey,\n              effect: effect\n            });\n\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2[\"catch\"](5);\n            return _context2.abrupt(\"return\", null);\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1'\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(_ref6) {\n  var dataHref = _ref6.dataHref,\n      inflightCache = _ref6.inflightCache,\n      isPrefetch = _ref6.isPrefetch,\n      hasMiddleware = _ref6.hasMiddleware,\n      isServerRender = _ref6.isServerRender,\n      parseJSON = _ref6.parseJSON,\n      persistCache = _ref6.persistCache,\n      isBackground = _ref6.isBackground,\n      unstable_skipClientCache = _ref6.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: 'prefetch'\n      } : {}, isPrefetch && hasMiddleware ? {\n        'x-middleware-prefetch': '1'\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : 'GET'\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: '',\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === 'Failed to fetch' || // firefox\n      err.message === 'NetworkError when attempting to fetch resource.' || // safari\n      err.message === 'Load failed') {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: 'HEAD'\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(_ref7) {\n  var url = _ref7.url,\n      router = _ref7.router;\n\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(_ref8) {\n  var route = _ref8.route,\n      router = _ref8.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref9) {\n    var _this2 = this;\n\n    var initialProps = _ref9.initialProps,\n        pageLoader = _ref9.pageLoader,\n        App = _ref9.App,\n        wrapApp = _ref9.wrapApp,\n        Component = _ref9.Component,\n        err = _ref9.err,\n        subscription = _ref9.subscription,\n        isFallback = _ref9.isFallback,\n        locale = _ref9.locale,\n        locales = _ref9.locales,\n        defaultLocale = _ref9.defaultLocale,\n        domainLocales = _ref9.domainLocales,\n        isPreview = _ref9.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this2.isFirstPopStateEvent;\n      _this2.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this2.pathname,\n            _query = _this2.query;\n\n        _this2.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this2.locale === state.options.locale && state.as === _this2.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this2._key = key;\n\n      var _ref10 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref10.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this2.isSsr && as === (0, _addbasepath.addBasePath)(_this2.asPath) && pathname === (0, _addbasepath.addBasePath)(_this2.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this2._bps && !_this2._bps(state)) {\n        return;\n      }\n\n      _this2.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this2._shallow,\n        locale: options.locale || _this2.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== '/_error') {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter/index.js\"),\n          BloomFilter = _require.BloomFilter;\n\n      var staticFilterData = {\"bitset\":{\"size\":24,\"content\":\"LIsL\"},\"hashes\":7,\"size\":20};\n      var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || '';\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware2({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this2.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change('pushState', url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change('replaceState', url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function _bfl(as, resolvedAs, locale, skipNavigate) {\n      var _this = this;\n\n      return _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var matchesBflStatic, matchesBflDynamic, _i, _arr, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i2, _arr2, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (false) {}\n\n                matchesBflStatic = false;\n                matchesBflDynamic = false;\n                _i = 0, _arr = [as, resolvedAs];\n\n              case 4:\n                if (!(_i < _arr.length)) {\n                  _context3.next = 35;\n                  break;\n                }\n\n                curAs = _arr[_i];\n\n                if (!curAs) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n                asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || _this.locale));\n\n                if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(_this.asPath, 'http://n').pathname))) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = _this._bfl_s) == null ? void 0 : _this__bfl_s.has(asNoSlash)) || !!((_this__bfl_s1 = _this._bfl_s) == null ? void 0 : _this__bfl_s1.has(asNoSlashLocale));\n                _i2 = 0, _arr2 = [asNoSlash, asNoSlashLocale];\n\n              case 12:\n                if (!(_i2 < _arr2.length)) {\n                  _context3.next = 27;\n                  break;\n                }\n\n                normalizedAS = _arr2[_i2];\n                // if any sub-path of as matches a dynamic filter path\n                // it should be hard navigated\n                curAsParts = normalizedAS.split('/');\n                i = 0;\n\n              case 16:\n                if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                currentPart = curAsParts.slice(0, i).join('/');\n\n                if (!(currentPart && ((_this__bfl_d = _this._bfl_d) == null ? void 0 : _this__bfl_d.has(currentPart)))) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                matchesBflDynamic = true;\n                return _context3.abrupt(\"break\", 24);\n\n              case 21:\n                i++;\n                _context3.next = 16;\n                break;\n\n              case 24:\n                _i2++;\n                _context3.next = 12;\n                break;\n\n              case 27:\n                if (!(matchesBflStatic || matchesBflDynamic)) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                if (!skipNavigate) {\n                  _context3.next = 30;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", true);\n\n              case 30:\n                handleHardNavigation({\n                  url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || _this.locale, _this.defaultLocale)),\n                  router: _this\n                });\n                return _context3.abrupt(\"return\", new Promise(function () {}));\n\n              case 32:\n                _i++;\n                _context3.next = 4;\n                break;\n\n              case 35:\n                return _context3.abrupt(\"return\", false);\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  }, {\n    key: \"change\",\n    value: function change(method, url, as, options, forcedScroll) {\n      var _this = this;\n\n      return _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if ((0, _islocalurl.isLocalURL)(url)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: url,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", false);\n\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h === 1;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 7;\n                return _this._bfl(as, undefined, options.locale);\n\n              case 7:\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                nextState = _extends._({}, _this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n\n                readyStateChange = _this.isReady !== true;\n                _this.isReady = true;\n                isSsr = _this.isSsr;\n\n                if (!isQueryUpdating) {\n                  _this.isSsr = false;\n                } // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n\n\n                if (!(isQueryUpdating && _this.clc)) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", false);\n\n              case 15:\n                prevLocale = nextState.locale;\n\n                if (true) {\n                  _context4.next = 28;\n                  break;\n                }\n\n                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n\n                if (typeof options.locale === 'undefined') {\n                  options.locale = nextState.locale;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n                localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, _this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                  as = (0, _formaturl.formatWithValidation)(parsedAs);\n                  url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, _this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(_this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                if (!didNavigate) {\n                  _context4.next = 28;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", new Promise(function () {}));\n\n              case 28:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark('routeChange');\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (_this._inFlightRoute && _this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);\n                  }\n\n                  _this.clc();\n\n                  _this.clc = null;\n                }\n\n                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, _this.defaultLocale));\n                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                _this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n\n                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context4.next = 52;\n                  break;\n                }\n\n                nextState.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                _this.changeState(method, url, as, _extends._({}, options, {\n                  scroll: false\n                }));\n\n                if (scroll) {\n                  _this.scrollToHash(cleanedAs);\n                }\n\n                _context4.prev = 41;\n                _context4.next = 44;\n                return _this.set(nextState, _this.components[nextState.route], null);\n\n              case 44:\n                _context4.next = 50;\n                break;\n\n              case 46:\n                _context4.prev = 46;\n                _context4.t0 = _context4[\"catch\"](41);\n\n                if ((0, _iserror[\"default\"])(_context4.t0) && _context4.t0.cancelled) {\n                  Router.events.emit('routeChangeError', _context4.t0, cleanedAs, routeProps);\n                }\n\n                throw _context4.t0;\n\n              case 50:\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return _context4.abrupt(\"return\", true);\n\n              case 52:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n                // trigger hard navigation\n\n                if (!((_this_components_pathname = _this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                  _context4.next = 57;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", new Promise(function () {}));\n\n              case 57:\n                _context4.prev = 57;\n                _context4.next = 60;\n                return Promise.all([_this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), _this.pageLoader.getMiddleware()]);\n\n              case 60:\n                _yield$Promise$all = _context4.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context4.next = 70;\n                break;\n\n              case 66:\n                _context4.prev = 66;\n                _context4.t1 = _context4[\"catch\"](57);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", false);\n\n              case 70:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = 'replaceState';\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n\n                _context4.t2 = !options.shallow;\n\n                if (!_context4.t2) {\n                  _context4.next = 81;\n                  break;\n                }\n\n                _context4.next = 80;\n                return _matchesMiddleware2({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: _this\n                });\n\n              case 80:\n                _context4.t2 = _context4.sent;\n\n              case 81:\n                isMiddlewareMatch = _context4.t2;\n\n                if (isQueryUpdating && isMiddlewareMatch) {\n                  shouldResolveHref = false;\n                }\n\n                if (!(shouldResolveHref && pathname !== '/_error')) {\n                  _context4.next = 96;\n                  break;\n                }\n\n                options._shouldResolveHref = true;\n\n                if (true) {\n                  _context4.next = 94;\n                  break;\n                }\n\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, _this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context4.next = 90;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", true);\n\n              case 90:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                _context4.next = 96;\n                break;\n\n              case 94:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 96:\n                if ((0, _islocalurl.isLocalURL)(as)) {\n                  _context4.next = 101;\n                  break;\n                }\n\n                if (false) {}\n\n                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 99:\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", false);\n\n              case 101:\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                routeMatch = false;\n\n                if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                  _context4.next = 119;\n                  break;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeregex.getRouteRegex)(route);\n                routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context4.next = 118;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param] && !routeRegex.groups[param].optional;\n                });\n\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context4.next = 116;\n                  break;\n                }\n\n                if (true) {\n                  console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n\n              case 116:\n                _context4.next = 119;\n                break;\n\n              case 118:\n                if (shouldInterpolate) {\n                  as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 119:\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeStart', as, routeProps);\n                }\n\n                isErrorRoute = _this.pathname === '/404' || _this.pathname === '/_error';\n                _context4.prev = 121;\n                _context4.next = 124;\n                return _this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch,\n                  unstable_skipClientCache: options.unstable_skipClientCache,\n                  isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                  isMiddlewareRewrite: isMiddlewareRewrite\n                });\n\n              case 124:\n                routeInfo = _context4.sent;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context4.next = 128;\n                  break;\n                }\n\n                _context4.next = 128;\n                return _this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n              case 128:\n                if ('route' in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n\n                  cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                  if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n\n                  if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                      rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n\n                    if (false) {}\n\n                    _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                } // If the routeInfo brings a redirect we simply apply it.\n\n\n                if (!('type' in routeInfo)) {\n                  _context4.next = 136;\n                  break;\n                }\n\n                if (!(routeInfo.type === 'redirect-internal')) {\n                  _context4.next = 134;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", _this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n              case 134:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", new Promise(function () {}));\n\n              case 136:\n                component = routeInfo.Component;\n\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script.handleClientScriptLoad)(script.props);\n                  });\n                } // handle redirect on client-transition\n\n\n                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                  _context4.next = 165;\n                  break;\n                }\n\n                if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                  _context4.next = 149;\n                  break;\n                }\n\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context4.next = 147;\n                  break;\n                }\n\n                parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context4.abrupt(\"return\", _this.change(method, newUrl, newAs, options));\n\n              case 147:\n                handleHardNavigation({\n                  url: destination,\n                  router: _this\n                });\n                return _context4.abrupt(\"return\", new Promise(function () {}));\n\n              case 149:\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context4.next = 165;\n                  break;\n                }\n\n                _context4.prev = 151;\n                _context4.next = 154;\n                return _this.fetchComponent('/404');\n\n              case 154:\n                notFoundRoute = '/404';\n                _context4.next = 160;\n                break;\n\n              case 157:\n                _context4.prev = 157;\n                _context4.t3 = _context4[\"catch\"](151);\n                notFoundRoute = '/_error';\n\n              case 160:\n                _context4.next = 162;\n                return _this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isNotFound: true\n                });\n\n              case 162:\n                routeInfo = _context4.sent;\n\n                if (!('type' in routeInfo)) {\n                  _context4.next = 165;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on /404\");\n\n              case 165:\n                if (isQueryUpdating && _this.pathname === '/_error' && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null;\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n                upcomingRouterState = _extends._({}, nextState, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                }); // When the page being rendered is the 404 page, we should only update the\n                // query parameters. Route changes here might add the basePath when it\n                // wasn't originally present. This is also why this block is before the\n                // below `changeState` call which updates the browser's history (changing\n                // the URL).\n\n                if (!(isQueryUpdating && isErrorRoute)) {\n                  _context4.next = 188;\n                  break;\n                }\n\n                _context4.next = 174;\n                return _this.getRouteInfo({\n                  route: _this.pathname,\n                  pathname: _this.pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isQueryUpdating: isQueryUpdating && !_this.isFallback\n                });\n\n              case 174:\n                routeInfo = _context4.sent;\n\n                if (!('type' in routeInfo)) {\n                  _context4.next = 177;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on \".concat(_this.pathname));\n\n              case 177:\n                if (_this.pathname === '/_error' && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                _context4.prev = 178;\n                _context4.next = 181;\n                return _this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 181:\n                _context4.next = 187;\n                break;\n\n              case 183:\n                _context4.prev = 183;\n                _context4.t4 = _context4[\"catch\"](178);\n\n                if ((0, _iserror[\"default\"])(_context4.t4) && _context4.t4.cancelled) {\n                  Router.events.emit('routeChangeError', _context4.t4, cleanedAs, routeProps);\n                }\n\n                throw _context4.t4;\n\n              case 187:\n                return _context4.abrupt(\"return\", true);\n\n              case 188:\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n\n                _this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n\n\n                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, _this.state);\n\n                if (canSkipUpdating) {\n                  _context4.next = 211;\n                  break;\n                }\n\n                _context4.prev = 192;\n                _context4.next = 195;\n                return _this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 195:\n                _context4.next = 204;\n                break;\n\n              case 197:\n                _context4.prev = 197;\n                _context4.t5 = _context4[\"catch\"](192);\n\n                if (!_context4.t5.cancelled) {\n                  _context4.next = 203;\n                  break;\n                }\n\n                routeInfo.error = routeInfo.error || _context4.t5;\n                _context4.next = 204;\n                break;\n\n              case 203:\n                throw _context4.t5;\n\n              case 204:\n                if (!routeInfo.error) {\n                  _context4.next = 207;\n                  break;\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n                }\n\n                throw routeInfo.error;\n\n              case 207:\n                if (false) {}\n\n                if (!isQueryUpdating) {\n                  Router.events.emit('routeChangeComplete', as, routeProps);\n                } // A hash mark # is the optional last part of a URL\n\n\n                hashRegex = /#.+$/;\n\n                if (shouldScroll && hashRegex.test(as)) {\n                  _this.scrollToHash(as);\n                }\n\n              case 211:\n                return _context4.abrupt(\"return\", true);\n\n              case 214:\n                _context4.prev = 214;\n                _context4.t6 = _context4[\"catch\"](121);\n\n                if (!((0, _iserror[\"default\"])(_context4.t6) && _context4.t6.cancelled)) {\n                  _context4.next = 218;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", false);\n\n              case 218:\n                throw _context4.t6;\n\n              case 219:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }))();\n    }\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (true) {\n        if (typeof window.history === 'undefined') {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === 'undefined') {\n          console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n          return;\n        }\n      }\n\n      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== 'pushState' ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        '', as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n      var _this = this;\n\n      return _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var props, _yield$_this$fetchCom, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                console.error(err);\n\n                if (!err.cancelled) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw err;\n\n              case 3:\n                if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                }); // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 7:\n                _context5.prev = 7;\n                _context5.next = 10;\n                return _this.fetchComponent('/_error');\n\n              case 10:\n                _yield$_this$fetchCom = _context5.sent;\n                Component = _yield$_this$fetchCom.page;\n                styleSheets = _yield$_this$fetchCom.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                _context5.prev = 15;\n                _context5.next = 18;\n                return _this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context5.sent;\n                _context5.next = 25;\n                break;\n\n              case 21:\n                _context5.prev = 21;\n                _context5.t0 = _context5[\"catch\"](15);\n                console.error('Error in error page `getInitialProps`: ', _context5.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context5.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context5.prev = 28;\n                _context5.t1 = _context5[\"catch\"](7);\n                return _context5.abrupt(\"return\", _this.handleRouteInfoError((0, _iserror[\"default\"])(_context5.t1) ? _context5.t1 : new Error(_context5.t1 + ''), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[7, 28], [15, 21]]);\n      }))();\n    }\n  }, {\n    key: \"getRouteInfo\",\n    value: function getRouteInfo(_ref11) {\n      var requestedRoute = _ref11.route,\n          pathname = _ref11.pathname,\n          query = _ref11.query,\n          as = _ref11.as,\n          resolvedAs = _ref11.resolvedAs,\n          routeProps = _ref11.routeProps,\n          locale = _ref11.locale,\n          hasMiddleware = _ref11.hasMiddleware,\n          isPreview = _ref11.isPreview,\n          unstable_skipClientCache = _ref11.unstable_skipClientCache,\n          isQueryUpdating = _ref11.isQueryUpdating,\n          isMiddlewareRewrite = _ref11.isMiddlewareRewrite,\n          isNotFound = _ref11.isNotFound;\n\n      var _this = this;\n\n      return _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require2, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$_this$_getData, props, cacheKey;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */\n                route = requestedRoute;\n                _context7.prev = 1;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: _this\n                });\n                existingInfo = _this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && _this.route === route)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", existingInfo);\n\n              case 6:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n\n                cachedRouteInfo = existingInfo && !('initial' in existingInfo) && false ? 0 : undefined;\n                isBackground = isQueryUpdating;\n                fetchNextDataParams = {\n                  dataHref: _this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? '/404' : resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: _this.isSsr,\n                  parseJSON: true,\n                  inflightCache: isBackground ? _this.sbc : _this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache,\n                  isBackground: isBackground\n                };\n\n                if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                  _context7.next = 14;\n                  break;\n                }\n\n                _context7.t0 = null;\n                _context7.next = 17;\n                break;\n\n              case 14:\n                _context7.next = 16;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: isNotFound ? '/404' : resolvedAs,\n                  locale: locale,\n                  router: _this\n                })[\"catch\"](function (err) {\n                  // we don't hard error during query updating\n                  // as it's un-necessary and doesn't need to be fatal\n                  // unless it is a fallback route and the props can't\n                  // be loaded\n                  if (isQueryUpdating) {\n                    return null;\n                  }\n\n                  throw err;\n                });\n\n              case 16:\n                _context7.t0 = _context7.sent;\n\n              case 17:\n                data = _context7.t0;\n\n                // when rendering error routes we don't apply middleware\n                // effects\n                if (data && (pathname === '/_error' || pathname === '/404')) {\n                  data.effect = undefined;\n                }\n\n                if (isQueryUpdating) {\n                  if (!data) {\n                    data = {\n                      json: self.__NEXT_DATA__.props\n                    };\n                  } else {\n                    data.json = self.__NEXT_DATA__.props;\n                  }\n                }\n\n                handleCancelled();\n\n                if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === 'redirect-internal' || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === 'redirect-external')) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", data.effect);\n\n              case 23:\n                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === 'rewrite')) {\n                  _context7.next = 36;\n                  break;\n                }\n\n                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                _context7.next = 27;\n                return _this.pageLoader.getPageList();\n\n              case 27:\n                pages = _context7.sent;\n\n                if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                  _context7.next = 36;\n                  break;\n                }\n\n                route = resolvedRoute;\n                pathname = data.effect.resolvedHref;\n                query = _extends._({}, query, data.effect.parsedAs.query);\n                resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, _this.locales).pathname); // Check again the cache with the new destination.\n\n                existingInfo = _this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware)) {\n                  _context7.next = 36;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", _extends._({}, existingInfo, {\n                  route: route\n                }));\n\n              case 36:\n                if (!(0, _isapiroute.isAPIRoute)(route)) {\n                  _context7.next = 39;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: _this\n                });\n                return _context7.abrupt(\"return\", new Promise(function () {}));\n\n              case 39:\n                _context7.t1 = cachedRouteInfo;\n\n                if (_context7.t1) {\n                  _context7.next = 44;\n                  break;\n                }\n\n                _context7.next = 43;\n                return _this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                  };\n                });\n\n              case 43:\n                _context7.t1 = _context7.sent;\n\n              case 44:\n                routeInfo = _context7.t1;\n\n                if (false) {}\n\n                _require2 = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require2.isValidElementType;\n\n                if (isValidElementType(routeInfo.Component)) {\n                  _context7.next = 49;\n                  break;\n                }\n\n                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n\n              case 49:\n                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get('x-middleware-skip');\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n\n                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                  delete _this.sdc[data.dataHref];\n                }\n\n                _context7.next = 54;\n                return _this._getData( /*#__PURE__*/_async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                  var dataHref, fetched;\n                  return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                    while (1) {\n                      switch (_context6.prev = _context6.next) {\n                        case 0:\n                          if (!shouldFetchData) {\n                            _context6.next = 8;\n                            break;\n                          }\n\n                          if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                            _context6.next = 3;\n                            break;\n                          }\n\n                          return _context6.abrupt(\"return\", {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                          });\n\n                        case 3:\n                          dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                            href: (0, _formaturl.formatWithValidation)({\n                              pathname: pathname,\n                              query: query\n                            }),\n                            asPath: resolvedAs,\n                            locale: locale\n                          });\n                          _context6.next = 6;\n                          return fetchNextData({\n                            dataHref: dataHref,\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n\n                        case 6:\n                          fetched = _context6.sent;\n                          return _context6.abrupt(\"return\", {\n                            cacheKey: fetched.cacheKey,\n                            props: fetched.json || {}\n                          });\n\n                        case 8:\n                          _context6.t0 = {};\n                          _context6.next = 11;\n                          return _this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                          });\n\n                        case 11:\n                          _context6.t1 = _context6.sent;\n                          return _context6.abrupt(\"return\", {\n                            headers: _context6.t0,\n                            props: _context6.t1\n                          });\n\n                        case 13:\n                        case \"end\":\n                          return _context6.stop();\n                      }\n                    }\n                  }, _callee6);\n                })));\n\n              case 54:\n                _yield$_this$_getData = _context7.sent;\n                props = _yield$_this$_getData.props;\n                cacheKey = _yield$_this$_getData.cacheKey;\n\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                  delete _this.sdc[cacheKey];\n                } // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n\n\n                if (!_this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return _context7.abrupt(\"return\", routeInfo);\n\n              case 68:\n                _context7.prev = 68;\n                _context7.t2 = _context7[\"catch\"](1);\n                return _context7.abrupt(\"return\", _this.handleRouteInfoError((0, _iserror.getProperError)(_context7.t2), pathname, query, as, routeProps));\n\n              case 71:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[1, 68]]);\n      }))();\n    }\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split('#'),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split('#'),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split('#'),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? '' : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === '' || hash === 'top') {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(url) {\n      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _this = this;\n\n      return _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (false) {}\n\n                return _context8.abrupt(\"return\");\n\n              case 2:\n                if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\");\n\n              case 4:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                urlPathname = parsed.pathname;\n                pathname = parsed.pathname, query = parsed.query;\n                originalPathname = pathname;\n\n                if (false) {}\n\n                _context8.next = 11;\n                return _this.pageLoader.getPageList();\n\n              case 11:\n                pages = _context8.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;\n                _context8.next = 16;\n                return _matchesMiddleware2({\n                  asPath: asPath,\n                  locale: locale,\n                  router: _this\n                });\n\n              case 16:\n                isMiddlewareMatch = _context8.sent;\n\n                if (true) {\n                  _context8.next = 27;\n                  break;\n                }\n\n                _context8.next = 20;\n                return (0, _routeloader.getClientBuildManifest)();\n\n              case 20:\n                _yield = _context8.sent;\n                rewrites = _yield.__rewrites;\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, _this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, _this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context8.next = 25;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\");\n\n              case 25:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), _this.locale);\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 27:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                if (true) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                _context8.t0 = null;\n                _context8.next = 36;\n                break;\n\n              case 33:\n                _context8.next = 35;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData({\n                      dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: originalPathname,\n                          query: query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale: locale\n                      }),\n                      hasMiddleware: true,\n                      isServerRender: _this.isSsr,\n                      parseJSON: true,\n                      inflightCache: _this.sdc,\n                      persistCache: !_this.isPreview,\n                      isPrefetch: true\n                    });\n                  },\n                  asPath: asPath,\n                  locale: locale,\n                  router: _this\n                });\n\n              case 35:\n                _context8.t0 = _context8.sent;\n\n              case 36:\n                data = _context8.t0;\n\n                /**\n                * If there was a rewrite we apply the effects of the rewrite on the\n                * current parameters for the prefetch.\n                */\n                if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n                  parsed.pathname = data.effect.resolvedHref;\n                  pathname = data.effect.resolvedHref;\n                  query = _extends._({}, query, data.effect.parsedAs.query);\n                  resolvedAs = data.effect.parsedAs.pathname;\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n                /**\n                * If there is a redirect to an external destination then we don't have\n                * to prefetch content as it will be unused.\n                */\n\n\n                if (!((data == null ? void 0 : data.effect.type) === 'redirect-external')) {\n                  _context8.next = 40;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\");\n\n              case 40:\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                _context8.next = 43;\n                return _this._bfl(asPath, resolvedAs, options.locale, true);\n\n              case 43:\n                if (!_context8.sent) {\n                  _context8.next = 45;\n                  break;\n                }\n\n                _this.components[urlPathname] = {\n                  __appRouter: true\n                };\n\n              case 45:\n                _context8.next = 47;\n                return Promise.all([_this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this.sdc,\n                    persistCache: !_this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                  }).then(function () {\n                    return false;\n                  })[\"catch\"](function () {\n                    return false;\n                  }) : false;\n                }), _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n\n              case 47:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }))();\n    }\n  }, {\n    key: \"fetchComponent\",\n    value: function fetchComponent(route) {\n      var _this = this;\n\n      return _async_to_generator._( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: _this\n                });\n                _context9.prev = 1;\n                _context9.next = 4;\n                return _this.pageLoader.loadPage(route);\n\n              case 4:\n                componentResult = _context9.sent;\n                handleCancelled();\n                return _context9.abrupt(\"return\", componentResult);\n\n              case 9:\n                _context9.prev = 9;\n                _context9.t0 = _context9[\"catch\"](1);\n                handleCancelled();\n                throw _context9.t0;\n\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[1, 9]]);\n      }))();\n    }\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this3 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this3.clc) {\n          _this3.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error('Loading initial props cancelled');\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (_ref12) {\n        var text = _ref12.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components['/_app'].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOzs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDOztBQUdBLFNBQVNDLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjtFQUMxQixLQUFJLElBQUlDLElBQVIsSUFBZ0JELEdBQWhCO0lBQW9CTixNQUFNLENBQUNDLGNBQVAsQ0FBc0JJLE1BQXRCLEVBQThCRSxJQUE5QixFQUFvQztNQUNwREMsVUFBVSxFQUFFLElBRHdDO01BRXBEQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBRDtJQUY0QyxDQUFwQztFQUFwQjtBQUlIOztBQUNESCxPQUFPLENBQUNGLE9BQUQsRUFBVTtFQUNiLFdBQVMsb0JBQVc7SUFDaEIsT0FBT1EsTUFBUDtFQUNILENBSFk7RUFJYkMsaUJBQWlCLEVBQUUsNkJBQVc7SUFDMUIsT0FBT0EsbUJBQVA7RUFDSCxDQU5ZO0VBT2JDLFNBQVMsRUFBRSxxQkFBVztJQUNsQixPQUFPQSxVQUFQO0VBQ0g7QUFUWSxDQUFWLENBQVA7O0FBV0EsSUFBTUMsbUJBQW1CLEdBQUdDLG1CQUFPLENBQUMsa0dBQUQsQ0FBbkM7O0FBQ0EsSUFBTUMsUUFBUSxHQUFHRCxtQkFBTyxDQUFDLDRFQUFELENBQXhCOztBQUNBLElBQU1FLHdCQUF3QixHQUFHRixtQkFBTyxDQUFDLDRHQUFELENBQXhDOztBQUNBLElBQU1HLHlCQUF5QixHQUFHSCxtQkFBTyxDQUFDLDhHQUFELENBQXpDOztBQUNBLElBQU1JLG9CQUFvQixHQUFHSixtQkFBTyxDQUFDLGdIQUFELENBQXBDOztBQUNBLElBQU1LLFlBQVksR0FBR0wsbUJBQU8sQ0FBQyxxRkFBRCxDQUE1Qjs7QUFDQSxJQUFNTSxPQUFPLEdBQUdOLG1CQUFPLENBQUMseUVBQUQsQ0FBdkI7O0FBQ0EsSUFBTU8sUUFBUSxH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Q2IsT0FBTyxLQUFLOEosS0FBTCxDQUFXVCxVQUFsQjtJQUNIOzs7U0FDRCxlQUFnQjtNQUNaLE9BQU8sS0FBS1MsS0FBTCxDQUFXUCxTQUFsQjtJQUNIOzs7Ozs7QUF5TEwsQ0FBQyxZQUFJO0VBQ0R2TixNQUFNLENBQUNvUSxNQUFQLEdBQWdCLENBQUMsR0FBR3JQLEtBQUssV0FBVCxHQUFoQjtBQUNILENBRkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanM/ODY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm91dGVyO1xuICAgIH0sXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc01pZGRsZXdhcmU7XG4gICAgfSxcbiAgICBjcmVhdGVLZXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlS2V5O1xuICAgIH1cbn0pO1xuY29uc3QgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9fYXN5bmNfdG9fZ2VuZXJhdG9yXCIpO1xuY29uc3QgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2V4dGVuZHNcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfaXNhcGlyb3V0ZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlXCIpO1xuY29uc3QgX2dldG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2NvbXBhcmVzdGF0ZXMgPSByZXF1aXJlKFwiLi91dGlscy9jb21wYXJlLXN0YXRlc1wiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2lzYm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi91dGlscy9vbWl0XCIpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgICAgICBjYW5jZWxsZWQ6IHRydWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21hdGNoZXNNaWRkbGV3YXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfbWF0Y2hlc01pZGRsZXdhcmUoKSB7XG4gICAgX21hdGNoZXNNaWRkbGV3YXJlID0gX2FzeW5jX3RvX2dlbmVyYXRvci5fKGZ1bmN0aW9uKihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXJzID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpKTtcbiAgICAgICAgaWYgKCFtYXRjaGVycykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShvcHRpb25zLmFzUGF0aCk7XG4gICAgICAgIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcbiAgICAgICAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgb3B0aW9ucy5sb2NhbGUpKTtcbiAgICAgICAgLy8gQ2hlY2sgb25seSBwYXRoIG1hdGNoIG9uIGNsaWVudC4gTWF0Y2hpbmcgXCJoYXNcIiBzaG91bGQgYmUgZG9uZSBvbiBzZXJ2ZXJcbiAgICAgICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG0pPT5uZXcgUmVnRXhwKG0ucmVnZXhwKS50ZXN0KGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9tYXRjaGVzTWlkZGxld2FyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmw7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyLCB1cmwsIGFzKSB7XG4gICAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIHVybCwgdHJ1ZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICBjb25zdCBocmVmV2FzQWJzb2x1dGUgPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzV2FzQWJzb2x1dGUgPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShyZXNvbHZlZEhyZWYpO1xuICAgIGNvbnN0IHByZXBhcmVkQXMgPSBhcyA/IHN0cmlwT3JpZ2luKCgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgYXMpKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgICAgIGFzOiBhc1dhc0Fic29sdXRlID8gcHJlcGFyZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX2Rlbm9ybWFsaXplcGFnZXBhdGguZGVub3JtYWxpemVQYWdlUGF0aCkocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFnZSkgJiYgKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhKHNvdXJjZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpXG4gICAgfTtcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLXJld3JpdGUnKTtcbiAgICBsZXQgcmV3cml0ZVRhcmdldCA9IHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLW1hdGNoZWQtcGF0aCcpO1xuICAgIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWF0Y2hlZC1wYXRoJyk7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnX19uZXh0X2RhdGFfY2F0Y2hhbGwnKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy9fZXJyb3InKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy80MDQnKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKCcvJykgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZXdyaXRlVGFyZ2V0ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJld3JpdGVUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZnNQYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZUluZm8ucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpXG4gICAgICAgICAgICBdKS50aGVuKChbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dKT0+e1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkU291cmNlLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IGFzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KShhcywgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCAocGF0aCk9PnJlc29sdmVEeW5hbWljUm91dGUocGF0aCwgcGFnZXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXRjaGVkUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IHJlc3VsdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzID0gcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgcmVzdWx0LnBhcnNlZEFzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUGF0aG5hbWUgIT09IGZzUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzUGF0aG5hbWUgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9ICFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSA/IHJlc29sdmVEeW5hbWljUm91dGUoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSwgcGFnZXMpIDogZnNQYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJlc29sdmVkSHJlZikpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCBtYXRjaGVzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Jld3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBczogcGFyc2VkUmV3cml0ZVRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoc291cmNlKTtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoX2V4dGVuZHMuXyh7fSwgKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIGJ1aWxkSWQ6ICcnXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QtZXh0ZXJuYWwnLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IGAke3BhdGhuYW1lfSR7c3JjLnF1ZXJ5fSR7c3JjLmhhc2h9YFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmVkaXJlY3QnKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShyZWRpcmVjdFRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKShfZXh0ZW5kcy5fKHt9LCAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiAnJ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWludGVybmFsJyxcbiAgICAgICAgICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgICAgICAgICAgIG5ld1VybDogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiAnbmV4dCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF93aXRoTWlkZGxld2FyZUVmZmVjdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF93aXRoTWlkZGxld2FyZUVmZmVjdHMoKSB7XG4gICAgX3dpdGhNaWRkbGV3YXJlRWZmZWN0cyA9IF9hc3luY190b19nZW5lcmF0b3IuXyhmdW5jdGlvbioob3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0geWllbGQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucyk7XG4gICAgICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgb3B0aW9ucy5mZXRjaERhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdCA9IHlpZWxkIGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZjogZGF0YS5kYXRhSHJlZixcbiAgICAgICAgICAgICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgdGV4dDogZGF0YS50ZXh0LFxuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICogRm9yIG5vdyB3ZSB3aWxsIG5vdCBjb25zaWRlciBtaWRkbGV3YXJlIGRhdGEgZXJyb3JzIHRvIGJlIGZhdGFsLlxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXG4gICAgICovIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF93aXRoTWlkZGxld2FyZUVmZmVjdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHYgPSAnX19uZXh0JztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7fVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKCdTU0dfREFUQV9OT1RfRk9VTkQnKTtcbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cywgb3B0aW9ucykge1xuICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgICAgIC8vID4gb3B0aW9uLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgJ3gtbmV4dGpzLWRhdGEnOiAnMSdcbiAgICAgICAgfSlcbiAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpIDogcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHsgZGF0YUhyZWYgLCBpbmZsaWdodENhY2hlICwgaXNQcmVmZXRjaCAsIGhhc01pZGRsZXdhcmUgLCBpc1NlcnZlclJlbmRlciAsIHBhcnNlSlNPTiAsIHBlcnNpc3RDYWNoZSAsIGlzQmFja2dyb3VuZCAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAgfSkge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiAncHJlZmV0Y2gnXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICAneC1taWRkbGV3YXJlLXByZWZldGNoJzogJzEnXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6ICdHRVQnXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpID09PSAnSEVBRCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi8gaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgfHwgZGF0YS5yZXNwb25zZS5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLWNhY2hlJykgPT09ICduby1jYWNoZScpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGlmICghdW5zdGFibGVfc2tpcENsaWVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8vIGNocm9tZVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09ICdGYWlsZWQgdG8gZmV0Y2gnIHx8IC8vIGZpcmVmb3hcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09ICdMb2FkIGZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICB9IDoge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybCAsIHJvdXRlciAgfSkge1xuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMICR7dXJsfSAke2xvY2F0aW9uLmhyZWZ9YCk7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xufVxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9ICh7IHJvdXRlICwgcm91dGVyICB9KT0+e1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYW5jZWwgPSByb3V0ZXIuY2xjID0gKCk9PntcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpPT57XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IuXyhmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VyQXMgb2YgW1xuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xuICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGN1ckFzLCAnaHR0cDovL24nKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IF90aGlzLmxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwoX3RoaXMuYXNQYXRoLCAnaHR0cDovL24nKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9zLCBfdGhpc19fYmZsX3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSBfdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MuaGFzKGFzTm9TbGFzaCkpIHx8ICEhKChfdGhpc19fYmZsX3MxID0gX3RoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5oYXMoYXNOb1NsYXNoTG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGhhcmQgbmF2aWdhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAmJiAoKF90aGlzX19iZmxfZCA9IF90aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5oYXMoY3VycmVudFBhcnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhcywgbG9jYWxlIHx8IF90aGlzLmxvY2FsZSwgX3RoaXMuZGVmYXVsdExvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IuXyhmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfY29tcG9uZW50c19wYXRobmFtZTtcbiAgICAgICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICAgICAgY29uc3QgaXNRdWVyeVVwZGF0aW5nID0gb3B0aW9ucy5faCA9PT0gMTtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5fYmZsKGFzLCB1bmRlZmluZWQsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gX2V4dGVuZHMuXyh7fSwgX3RoaXMuc3RhdGUpO1xuICAgICAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSBfdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBpc1NzciA9IF90aGlzLmlzU3NyO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgICAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBfdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IF90aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIF90aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIF90aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX2xvY2FsZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSBfdGhpcy5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfbG9jYWxlcy5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSAoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKF90aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiBfdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHsoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShgJHtuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bmV4dFN0YXRlLmxvY2FsZX1gfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJyl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9ZmFsc2UgLCBzY3JvbGwgPXRydWUgIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBzaGFsbG93XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKF90aGlzLl9pbkZsaWdodFJvdXRlICYmIF90aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCBfdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmNsYygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCBfdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIF90aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIF90aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBfZXh0ZW5kcy5fKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KG5leHRTdGF0ZSwgX3RoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICBpZiAoKF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUgPSBfdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgICAgICBpZiAoIV90aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoJy8nKSAmJiAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpIHx8ICEoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSAhb3B0aW9ucy5zaGFsbG93ICYmICh5aWVsZCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCBfdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgICAgICBsZXQgcm91dGVNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7c2hvdWxkSW50ZXJwb2xhdGUgPyBgSW50ZXJwb2xhdGluZyBocmVmYCA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgKyBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IF90aGlzLnBhdGhuYW1lID09PSAnLzQwNCcgfHwgX3RoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLCBfcm91dGVJbmZvX3Byb3BzO1xuICAgICAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuX2JmbChhcywgJ3Jlc29sdmVkQXMnIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdyb3V0ZScgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcm91dGVJbmZvLnJvdXRlIHx8IHJvdXRlO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocm91dGVNYXRjaCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnlba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXdyaXRlQXMgPSBwcmVmaXhlZEFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJld3JpdGVBcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCBfdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBjdXJSb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcm91dGVJbmZvLkNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfc2NyaXB0LmhhbmRsZUNsaWVudFNjcmlwdExvYWQpKHNjcmlwdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWRIcmVmLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyhfdGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5mZXRjaENvbXBvbmVudCgnLzQwNCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvX2Vycm9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHlpZWxkIF90aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTm90Rm91bmQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gLzQwNGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgX3RoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJyAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9yb3V0ZUluZm9fcm91dGU7XG4gICAgICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgbmV4dFN0YXRlLnJvdXRlID09PSAoKF9yb3V0ZUluZm9fcm91dGUgPSByb3V0ZUluZm8ucm91dGUpICE9IG51bGwgPyBfcm91dGVJbmZvX3JvdXRlIDogcm91dGUpO1xuICAgICAgICAgICAgICAgIHZhciBfb3B0aW9uc19zY3JvbGw7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9vcHRpb25zX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPSBudWxsID8gX29wdGlvbnNfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSBfZXh0ZW5kcy5fKHt9LCBuZXh0U3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcGFnZSBiZWluZyByZW5kZXJlZCBpcyB0aGUgNDA0IHBhZ2UsIHdlIHNob3VsZCBvbmx5IHVwZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBiZWxvdyBgY2hhbmdlU3RhdGVgIGNhbGwgd2hpY2ggdXBkYXRlcyB0aGUgYnJvd3NlcidzIGhpc3RvcnkgKGNoYW5naW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxLCBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEsIF9yb3V0ZUluZm9fcHJvcHMxO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IF90aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IF90aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAke190aGlzLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNjcm9sbFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgX3RoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSByb3V0ZUluZm8uZXJyb3IgPSByb3V0ZUluZm8uZXJyb3IgfHwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIHJvdXRlSW5mby5lcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIGhhc2hSZWdleC50ZXN0KGFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICAnJywgYXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVJvdXRlSW5mb0Vycm9yKGVyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvci5fKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0geWllbGQgX3RoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0Um91dGVJbmZvKHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlICwgcGF0aG5hbWUgLCBxdWVyeSAsIGFzICwgcmVzb2x2ZWRBcyAsIHJvdXRlUHJvcHMgLCBsb2NhbGUgLCBoYXNNaWRkbGV3YXJlICwgaXNQcmV2aWV3ICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICwgaXNRdWVyeVVwZGF0aW5nICwgaXNNaWRkbGV3YXJlUmV3cml0ZSAsIGlzTm90Rm91bmQgIH0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IuXyhmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gX3RoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgX3RoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKCdpbml0aWFsJyBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnID8gZXhpc3RpbmdJbmZvIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogX3RoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gJy80MDQnIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IGlzQmFja2dyb3VuZCA/IF90aGlzLnNiYyA6IF90aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoZmV0Y2hOZXh0RGF0YVBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/ICcvNDA0JyA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgKHBhdGhuYW1lID09PSAnL19lcnJvcicgfHwgcGF0aG5hbWUgPT09ICcvNDA0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lZmZlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdC50eXBlKSA9PT0gJ3JlZGlyZWN0LWludGVybmFsJyB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09ICdyZWRpcmVjdC1leHRlcm5hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QyID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QyLnR5cGUpID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IHlpZWxkIF90aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYW4gYmUgcmV0dXJuZWQgYW5kIHRoaXMgc2hvdWxkIHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgPSByZXNvbHZlZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IF9leHRlbmRzLl8oe30sIHF1ZXJ5LCBkYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBhZ2FpbiB0aGUgY2FjaGUgd2l0aCB0aGUgbmV3IGRlc3RpbmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gX3RoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiBfdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gY29weSB0aGUgZXhpc3RpbmcgaW5mb3JtYXRpb24gdG8gdGhlIHJld3JpdHRlbiBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcy5fKHt9LCBleGlzdGluZ0luZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mbyB8fCAoeWllbGQgX3RoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUFxuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfcmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1za2lwJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1A7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAod2FzQmFpbGVkUHJlZmV0Y2ggJiYgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgLCBjYWNoZUtleSAgfSA9IHlpZWxkIF90aGlzLl9nZXREYXRhKC8qI19fUFVSRV9fKi8gX2FzeW5jX3RvX2dlbmVyYXRvci5fKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IHlpZWxkIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBfdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IF90aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGZldGNoZWQuanNvbiB8fCB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogeWllbGQgX3RoaXMuZ2V0SW5pdGlhbFByb3BzKHJvdXRlSW5mby5Db21wb25lbnQsIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlczogX3RoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBfdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgICAgICAvLyBtaWRkbGV3YXJlIGNhbiBza2lwIGNhY2hlIHBlciByZXF1ZXN0IHdpdGhcbiAgICAgICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuc2RjW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2Uga2ljayBvZmYgYSBIRUFEIHJlcXVlc3QgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc1ByZXZpZXcgJiYgcm91dGVJbmZvLl9fTl9TU0cgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBfdGhpcy5zYmNcbiAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcyk7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgc2V0KHN0YXRlLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50LCByZXNldFNjcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi8gYmVmb3JlUG9wU3RhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5fYnBzID0gY2I7XG4gICAgfVxuICAgIG9ubHlBSGFzaENoYW5nZShhcykge1xuICAgICAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoID0gJyddID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT53aW5kb3cuc2Nyb2xsVG8oMCwgMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgY29uc3QgcmF3SGFzaCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKTtcbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+aWRFbC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdO1xuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT5uYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBwcmVmZXRjaCh1cmwsIGFzUGF0aCA9IHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yLl8oZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF9pc2JvdC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICAgICAgY29uc3QgdXJsUGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IF90aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSB5aWVsZCBfdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZSA9IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiBfdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9IHlpZWxkIG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSB5aWVsZCAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc1BhdGgsIF90aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgX3RoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09ICdzdHJpY3QnID8gbnVsbCA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogX3RoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogX3RoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhX3RoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF9leHRlbmRzLl8oe30sIHF1ZXJ5LCBkYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgaWYgKHlpZWxkIF90aGlzLl9iZmwoYXNQYXRoLCByZXNvbHZlZEFzLCBvcHRpb25zLmxvY2FsZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgX19hcHBSb3V0ZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3NnID8gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgPyBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmIDogX3RoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBfdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFfdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKCk9PmZhbHNlKS5jYXRjaCgoKT0+ZmFsc2UpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgX3RoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yLl8oZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IHlpZWxkIF90aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oKHsgdGV4dCAgfSk9Pih7XG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCByb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XG4gICAgfVxuICAgIGdldCBhc1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcbiAgICB9XG4gICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xuICAgIH1cbiAgICBnZXQgaXNGYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcbiAgICB9XG4gICAgZ2V0IGlzUHJldmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscy5nZXRVUkwpKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCAsIGFzICwgb3B0aW9ucyAsIGtleSAgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMuYXNQYXRoKSAmJiBwYXRobmFtZSA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xuICAgICAgICAgICAgICAgIF9oOiAwXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgIH0gPSByZXF1aXJlKCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEuaGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoc3RhdGljRmlsdGVyRGF0YS5zaXplLCBzdGF0aWNGaWx0ZXJEYXRhLmhhc2hlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5zaXplLCBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGhcbiAgICAgICAgICAgICAgICB9KS50aGVuKChtYXRjaGVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgbWF0Y2hlcyA/IGFzUGF0aCA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksIGFzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuKCgpPT57XG4gICAgUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xufSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiY3JlYXRlS2V5IiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJfZXh0ZW5kcyIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIl9yb3V0ZWxvYWRlciIsIl9zY3JpcHQiLCJfaXNlcnJvciIsIl8iLCJfZGVub3JtYWxpemVwYWdlcGF0aCIsIl9ub3JtYWxpemVsb2NhbGVwYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNkeW5hbWljIiwiX3BhcnNlcmVsYXRpdmV1cmwiLCJfcmVzb2x2ZXJld3JpdGVzIiwiX3JvdXRlbWF0Y2hlciIsIl9yb3V0ZXJlZ2V4IiwiX2Zvcm1hdHVybCIsIl9kZXRlY3Rkb21haW5sb2NhbGUiLCJfcGFyc2VwYXRoIiwiX2FkZGxvY2FsZSIsIl9yZW1vdmVsb2NhbGUiLCJfcmVtb3ZlYmFzZXBhdGgiLCJfYWRkYmFzZXBhdGgiLCJfaGFzYmFzZXBhdGgiLCJfaXNhcGlyb3V0ZSIsIl9nZXRuZXh0cGF0aG5hbWVpbmZvIiwiX2Zvcm1hdG5leHRwYXRobmFtZWluZm8iLCJfY29tcGFyZXN0YXRlcyIsIl9pc2xvY2FsdXJsIiwiX2lzYm90IiwiX29taXQiLCJfcmVzb2x2ZWhyZWYiLCJfaW50ZXJwb2xhdGVhcyIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwiX21hdGNoZXNNaWRkbGV3YXJlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJvdXRlciIsInBhZ2VMb2FkZXIiLCJnZXRNaWRkbGV3YXJlIiwibWF0Y2hlcnMiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJhc1BhdGhuYW1lIiwicGF0aG5hbWUiLCJjbGVhbmVkQXMiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwicmV3cml0ZXMiLCJfX3Jld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsIl93aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJmZXRjaERhdGEiLCJkYXRhIiwiZGF0YUhyZWYiLCJlZmZlY3QiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJfX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OIiwid2luZG93IiwiaGlzdG9yeSIsInYiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJvayIsInN0YXR1cyIsInRyeVRvUGFyc2VBc0pTT04iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImZldGNoTmV4dERhdGEiLCJpbmZsaWdodENhY2hlIiwiaXNQcmVmZXRjaCIsImhhc01pZGRsZXdhcmUiLCJpc1NlcnZlclJlbmRlciIsInBhcnNlSlNPTiIsInBlcnNpc3RDYWNoZSIsImlzQmFja2dyb3VuZCIsInVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIl9wYXJhbXNfbWV0aG9kIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJfdHJ5VG9QYXJzZUFzSlNPTiIsIm5vdEZvdW5kIiwibWFya0Fzc2V0RXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwiaGFzaGVzIiwiX2JmbF9zIiwic2l6ZSIsIl9iZmxfZCIsImV2ZW50cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwic3ViIiwiX3dyYXBBcHAiLCJpc0xvY2FsZURvbWFpbiIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImRldGVjdERvbWFpbkxvY2FsZSIsImhvc3RuYW1lIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJiYWNrIiwiZm9yd2FyZCIsInNraXBOYXZpZ2F0ZSIsIl90aGlzIiwibWF0Y2hlc0JmbFN0YXRpYyIsIm1hdGNoZXNCZmxEeW5hbWljIiwiY3VyQXMiLCJhc05vU2xhc2giLCJhc05vU2xhc2hMb2NhbGUiLCJfdGhpc19fYmZsX3MiLCJoYXMiLCJfdGhpc19fYmZsX3MxIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsIl90aGlzX19iZmxfZCIsImlzTG9jYWxVUkwiLCJpc1F1ZXJ5VXBkYXRpbmciLCJfYmZsIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImRpZE5hdmlnYXRlIiwiX3RoaXNfbG9jYWxlcyIsImRldGVjdGVkRG9tYWluIiwiZG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwic2Nyb2xsIiwicm91dGVQcm9wcyIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsImxvY2FsZUNoYW5nZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsInBhcnNlZCIsIl90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUiLCJfX2FwcFJvdXRlciIsInVybElzTmV3IiwicGFyc2VkQXNQYXRobmFtZSIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0IiwicCIsImV4dGVybmFsRGVzdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJtaXNzaW5nUGFyYW1zIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJjb25zb2xlIiwid2FybiIsIm9taXQiLCJpc0Vycm9yUm91dGUiLCJnZXRSb3V0ZUluZm8iLCJyb3V0ZUluZm8iLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJmb3JFYWNoIiwicHJlZml4ZWRBcyIsInJld3JpdGVBcyIsImxvY2FsZVJlc3VsdCIsImN1clJvdXRlTWF0Y2giLCJjb21wb25lbnQiLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJzY3JpcHRzIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsIm5vdEZvdW5kUm91dGUiLCJpc05vdEZvdW5kIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzIiwic3RhdHVzQ29kZSIsIl9yb3V0ZUluZm9fcHJvcHMiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX3JvdXRlSW5mb19yb3V0ZSIsInNob3VsZFNjcm9sbCIsIl9vcHRpb25zX3Njcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSIsIl9yb3V0ZUluZm9fcHJvcHMxIiwiY2FuU2tpcFVwZGF0aW5nIiwiY29tcGFyZVJvdXRlclN0YXRlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhc2hSZWdleCIsImxvYWRFcnJvckZhaWwiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsInJlcXVlc3RlZFJvdXRlIiwiZXhpc3RpbmdJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiZmV0Y2hOZXh0RGF0YVBhcmFtcyIsImdldERhdGFIcmVmIiwic2tpcEludGVycG9sYXRpb24iLCJfZGF0YV9lZmZlY3QiLCJfZGF0YV9lZmZlY3QxIiwiX2RhdGFfZWZmZWN0MiIsInJlc29sdmVkUm91dGUiLCJpc0FQSVJvdXRlIiwicmVzIiwibW9kIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwid2FzQmFpbGVkUHJlZmV0Y2giLCJfZGF0YV9yZXNwb25zZSIsInNob3VsZEZldGNoRGF0YSIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVybFBhdGhuYW1lIiwib3JpZ2luYWxQYXRobmFtZSIsIl9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsIl9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSIsImxvYWRQYWdlIiwiY29tcG9uZW50UmVzdWx0IiwiZm4iLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});